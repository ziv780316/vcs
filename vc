#!/bin/bash

msg_info ()
{
	msg=$1
	echo "[vc info] $msg"
}

msg_error ()
{
	msg=$1
	echo "[vc error] $msg"
	exit 1
}

msg_warn ()
{
	msg=$1
	echo "[vc warn] $msg"
}

commit_with_changelog ()
{
	msg_info "start commit process"

	# fetch user information
	user_name=`git config --get user.name`
	user_email=`git config --get user.email`
	tempfile=`mktemp /tmp/vc.XXXXXXXX`
	if [ $? -ne 0 ]; then
		msg_error "create tempfile fail"
	fi

	# fetch all local cached file (file by git add)
	staged_files=`git diff --name-only --cached`

	# redirect to tempfile and produce template
	pid=$$ 
	origin_fd_1_file=$(readlink /proc/$pid/fd/1)
	if [ $? -ne 0 ]; then
		msg_error "readlink fail"
	fi

	echo "redirect PID=$pid stdout from $origin_fd_1_file --> $tempfile"
	exec 1>$tempfile
	if [ $? -ne 0 ]; then
		msg_error "redirect $origin_fd_1_file --> $tempfile fail"
	fi
	echo "-------------------------------------------"
	echo "user  = ${user_name}"
	echo "email = ${user_email}"
	echo "[Description]"
	echo ""
	echo "[Commit Files]"
	echo "$staged_files"
	echo ""
	exec 1>>$origin_fd_1_file
	echo "redirect stdout from $tempfile --> $origin_fd_1_file"
	if [ $? -ne 0 ]; then
		msg_error "redirect $tempfile --> $origin_fd_1_file fail "
	fi

	# modify change log
	vim $tempfile

	# confirm commit
	printf "[confirm] commit (Y/N) ? "
	read -n 1 response
	if [ $response == "Y" -o $response == "y" ]; then
		echo -e "\ncommit ..."
		git commit -F $tempfile

		# push code to local branch (master) to remote repository (origin)
		git push origin master
	else
		echo -e "\nabort"
	fi

	# clean-up
	rm $tempfile
}

query_file_status ()
{
	msg_info "start query status"
	
	file=$*
	git status -s $file
	if [ $? -ne 0 ]; then
		msg_error "query '$file' status fail "
	fi
}

add_file ()
{
	msg_info "add '$file'"
	
	file=$*
	git add $file

	if [ $? -ne 0 ]; then
		msg_error "add '$file' fail "
	fi
}

revert_file ()
{
	msg_info "revert '$file'"
	
	file=$*
	git reset $file

	if [ $? -ne 0 ]; then
		msg_error "revert '$file' fail "
	fi
}

query_file_change_log ()
{
	msg_info "start query change log"
	
	file=$*
	git log $file
	if [ $? -ne 0 ]; then
		msg_error "query '$file' cnange log fail "
	fi
}

sync_code ()
{
	msg_info "start sync code"
	
	git checkout remotes/origin/master $file
	if [ $? -ne 0 ]; then
		msg_error "sync '$file' fail "
	fi
}

show_help ()
{
	echo "-----------------------------"
	echo "|            VCS            |"
	echo "-----------------------------"
	echo "[query status]"
	echo "  vc -s|--status file1 file2"
	echo ""
	echo "[query log]"
	echo "  vc -l|--log file1 file2"
	echo ""
	echo "[add file]"
	echo "  vc -a|--add file1 file2"
	echo ""
	echo "[revert file]"
	echo "  vc -r|--revert file1 file2"
	echo ""
	echo "[commit and edit change log]"
	echo "  vc -c|--commit"
	echo ""
	echo "[sync code]"
	echo "  vc -y|--sync"
}


# $@ is array of arguments, $* is single string contain all arguments
args="$@"

# change -s file1 file2  ==>  -s "file1 file2"
quote_args=`echo $args | sed 's/\(--\?[^- ]\+\) \([^-]\+\)$/\1 "\2"/g'`

# change -s file1 file2 -h   ==>  -s "file1 file2" -h
quote_args=`echo $quote_args | sed 's/\(--\?[^- ]\+\) \([^-]\+\) -/\1 "\2" -/g'`

# assign quote_args to $@
eval set -- "$quote_args" 

msg_info "arguments: $args"
msg_info "quote arguments: $quote_args"

# use getopt to parse command line arguments, use "$@" in for loop will handle quote string
options=$(getopt -o vhs:ca:r:l:y: --long version,help,status:,commit,add:,revert:,log:,sync: -- "$@")

return_val=$?
if [ $return_val -ne 0 ]; then
	msg_error "parse command line arguments fail (return $return_val)"
fi

msg_info "options: $options" # -- mean end of options, it will not process by eval set

# set -- assign $options to $1, $2 ...
eval set -- "$options" 

eof_argument=false
while [ !$eof_argument ]; do
	option=$1
	case "$option" in 
	-h)
		show_help
		;;
	-v|--version)
		echo "vc 1.0"
		echo "$(git --version)"
		;;
	-s|--status)
		shift 
		file=$1
		query_file_status $file
		;;
	-c|--commit)
		commit_with_changelog 
		;;
	-a|--add)
		shift 
		file=$1
		add_file $file
		;;
	-r|--revert)
		shift 
		file=$1
		revert_file $file
		;;
	-l|--log)
		shift 
		file=$1
		query_file_change_log $file
		;;
	-y|--sync)
		shift
		file=$1
		sync_code $file
		;;
	--) 
		# -- (end of options)
		shift 
		eof_argument=true
		break
		;;
	esac

	shift # move $1 to next argument
done
