#!/bin/bash

remote_branch="origin/master"

msg_info ()
{
	msg=$1
	echo "[vc info] $msg"
}

msg_error ()
{
	msg=$1
	echo "[vc error] $msg"
	exit 1
}

msg_warn ()
{
	msg=$1
	echo "[vc warn] $msg"
}

commit_with_changelog ()
{
	msg_info "start commit process"

	# get user information
	user_name=`git config --get user.name`
	user_email=`git config --get user.email`
	tempfile=`mktemp /tmp/vc.XXXXXXXX`
	if [ $? -ne 0 ]; then
		msg_error "create tempfile fail"
	fi

	# get all local staged file (file by git add)
	staged_files=`git diff --name-only --staged`

	# redirect to tempfile and produce template
	pid=$$ 
	origin_fd_1_file=$(readlink /proc/$pid/fd/1)
	if [ $? -ne 0 ]; then
		rm $tempfile
		msg_error "readlink fail"
	fi

	echo "redirect PID=$pid stdout from $origin_fd_1_file --> $tempfile"
	exec 1>$tempfile
	if [ $? -ne 0 ]; then
		rm $tempfile
		msg_error "redirect $origin_fd_1_file --> $tempfile fail"
	fi
	commit_date=`date '+%Y/%m/%d %H:%M:%S'`
	echo "$commit_date ${user_name}"
	echo "[Description]"
	echo ""
	echo "[Commit Files]"
	echo "$staged_files"
	echo ""
	echo "-------------------------------------------"
	exec 1>>$origin_fd_1_file
	echo "redirect stdout from $tempfile --> $origin_fd_1_file"
	if [ $? -ne 0 ]; then
		rm $tempfile
		msg_error "redirect $tempfile --> $origin_fd_1_file fail "
	fi

	# modify change log
	vim $tempfile

	# confirm commit
	printf "[confirm] commit (Y/N) ? "
	read -n 1 response
	if [ $response == "Y" -o $response == "y" ]; then
		echo -e "\ncommit ..."
		git commit -F $tempfile

		# push code to local branch (master) to remote repository (origin)
		git push origin master
	else
		echo -e "\nabort"
	fi

	# clean-up
	rm $tempfile
}

query_file_status ()
{
	msg_info "start query status"
	
	file=$*
	git status -s $file
	if [ $? -ne 0 ]; then
		msg_error "query '$file' status fail "
	fi
}

add_file ()
{
	file=$*
	msg_info "add file '$file'"
	
	git add $file

	if [ $? -ne 0 ]; then
		msg_error "add '$file' fail "
	fi
}

revert_file ()
{
	msg_info "revert '$file'"
	
	file=$*
	git reset $file

	if [ $? -ne 0 ]; then
		msg_error "revert '$file' fail "
	fi
}

query_file_change_log ()
{
	msg_info "start query change log"
	
	# get branch head of remote repositories
	git fetch
	if [ $? -ne 0 ]; then
		msg_error "get fetch fail "
	fi

	file=$*
	git log --pretty=oneline --abbrev-commit $remote_branch -- $file
	if [ $? -ne 0 ]; then
		msg_error "query '$file' cnange log fail "
	fi
}

update_exist_code ()
{
	msg_info "update exist code"

	# get branch head of remote repositories
	git fetch
	if [ $? -ne 0 ]; then
		msg_error "get fetch fail "
	fi

	# update (merge FETCH_HEAD)
	git merge origin/master
	if [ $? -ne 0 ]; then
		msg_error "merge FETCH_HEAD fail "
	fi
}

sync_missing_code ()
{
	msg_info "start sync code"

	file=$1

	origin_branch=`git rev-parse --abbrev-ref HEAD`
	if [ $? -ne 0 ]; then
		msg_error "get current branch fail "
	fi

	echo "switch branch from '$origin_branch' --> 'remotes/origin/master'"
	
	git checkout -q remotes/origin/master 
	if [ $? -ne 0 ]; then
		msg_error "switch branch fail "
	fi

	git checkout $file
	if [ $? -ne 0 ]; then
		msg_error "sync '$file' fail "
	fi

	git checkout -q $origin_branch
	if [ $? -ne 0 ]; then
		msg_error "switch branch fail "
	fi
	echo "switch branch from 'remotes/origin/master' --> '$origin_branch' "
}

diff_files ()
{
	msg_info "start diff file"

	vimdiff_version=`vimdiff --version`
	if [ $? -ne 0 ]; then
		msg_error "cannot find vimdiff"
	fi

	# get branch head of remote repositories
	git fetch
	if [ $? -ne 0 ]; then
		msg_error "get fetch fail "
	fi

	num_args=$#
	if [ $num_args -eq 1 ]; then
		file=$1
		git difftool --no-prompt --tool=vimdiff $remote_branch -- $file
		if [ $? -ne 0 ]; then
			msg_error "diff '$file' fail "
		fi
	elif [ $num_args -eq 3 ]; then
		file=$1
		commit_id1=$2
		commit_id2=$3
		git difftool --no-prompt --tool=vimdiff $commit_id1 $commit_id2 -- $file
		if [ $? -ne 0 ]; then
	 		msg_error "diff '$file' fail "
		fi
	else
		msg_error "invalid diff arguments"
	fi
}

show_conflict_list ()
{
	msg_info "start show conflict list"

	git diff --name-only $remote_branch -- $dir
	if [ $? -ne 0 ]; then
		msg_error "diff '$dir' fail "
	fi
}

get_code ()
{
	msg_info "start get code"

	# get branch head of remote repositories
	git fetch
	if [ $? -ne 0 ]; then
		msg_error "get fetch fail "
	fi
	
	num_args=$#
	if [ $num_args -eq 2 ]; then
		file=$1
		commit_id=$2
		dump_name="${file}#${commit_id}"
		git show $commit_id:$file > $dump_name
		if [ $? -ne 0 ]; then
			rm -f $dump_name
			msg_error "get '$file (id=$commit_id)' fail"
		else
			msg_info "dump file '$dump_name'"
		fi
	else
		msg_error "invalid get arguments"
	fi
}

merge_code ()
{
	local_branch=`git rev-parse --abbrev-ref HEAD`
	if [ $? -ne 0 ]; then
		msg_error "get local branch fail "
	fi

	msg_info "start merge code from branch $remote_branch to $local_branch"

	# get branch head of remote repositories
	git fetch
	if [ $? -ne 0 ]; then
		msg_error "get fetch fail "
	fi

	file=$1
	git checkout $remote_branch -- $file
	if [ $? -ne 0 ]; then
		msg_error "checkout file fail "
	fi
}

show_help ()
{
	echo "-----------------------------"
	echo "|            VCS            |"
	echo "-----------------------------"
	echo "[query status]"
	echo "  vc -t|--status file1 file2 ..."
	echo ""
	echo "[query log]"
	echo "  vc -l|--log file1 file2 ..."
	echo ""
	echo "[add file]"
	echo "  vc -a|--add file1 file2 ..."
	echo ""
	echo "[revert file]"
	echo "  vc -r|--revert file1 file2 ..."
	echo ""
	echo "[commit and edit change log]"
	echo "  vc -c|--commit"
	echo ""
	echo "[sync code]"
	echo "  vc -s|--sync file"
	echo "  vc -s|--sync directory"
	echo ""
	echo "[diff file]"
	echo "  vc -d|--diff file"
	echo "  vc -d|--diff file commit_id1 commit_id2"
	echo "  vc -d|--diff directory"
	echo ""
	echo "[show conflict]"
	echo "  vc -f|--conflict"
	echo ""
	echo "[get code]"
	echo "  vc -g|--get file commit_id (dump to file#commit_id)"
	echo ""
	echo "[merge code]"
	echo "  vc -m|--merge file (replace local file by file on remote branch)"
}


# $@ is array of arguments, $* is single string contain all arguments
args="$@"

# change -s file1 file2  ==>  -s "file1 file2"
quote_args=`echo $args | sed 's/\(--\?[^- ]\+\) \([^-]\+\)$/\1 "\2"/g'`

# change -s file1 file2 -h   ==>  -s "file1 file2" -h
quote_args=`echo $quote_args | sed 's/\(--\?[^- ]\+\) \([^-]\+\) -/\1 "\2" -/g'`

# assign quote_args to $@
eval set -- "$quote_args" 

msg_info "arguments: $args"
msg_info "quote arguments: $quote_args"

# use getopt to parse command line arguments, use "$@" in for loop will handle quote string
options=$(getopt -o vht:ca:r:l:sd:g:fm: --long version,help,status:,commit,add:,revert:,log:,sync:,diff:,conflict,get:,merge: -- "$@")

return_val=$?
if [ $return_val -ne 0 ]; then
	msg_error "parse command line arguments fail (return $return_val)"
fi

msg_info "options: $options" # -- mean end of options, it will not process by eval set

# set -- assign $options to $1, $2 ...
eval set -- "$options" 

eof_argument=false
while [ !$eof_argument ]; do
	option=$1
	case "$option" in 
	-h)
		show_help
		;;
	-v|--version)
		echo "vc 1.0"
		echo "$(git --version)"
		;;
	-t|--status)
		shift 
		args=$1
		query_file_status $args
		;;
	-c|--commit)
		commit_with_changelog 
		;;
	-a|--add)
		shift 
		args=$1
		add_file $args
		;;
	-r|--revert)
		shift 
		args=$1
		revert_file $args
		;;
	-l|--log)
		shift 
		args=$1
		query_file_change_log $args
		;;
	-s|--sync)
		update_exist_code 
		;;
	-d|--diff)
		shift
		args=$1
		diff_files $args
		;;
	-f|--conflict)
		show_conflict_list 
		;;
	-g|--get)
		shift
		args=$1
		get_code $args
		;;
	-m|--merge)
		shift
		args=$1
		merge_code $args
		;;
	--) 
		# -- (end of options)
		shift 
		eof_argument=true
		break
		;;
	esac

	shift # move $1 to next argument
done
