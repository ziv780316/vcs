#!/bin/bash

remote_branch="origin/master"

debug=false
if [ "$VC_DEBUG_INFO" != "" ]; then
	debug=true
fi

msg_info ()
{
	msg=$1
	echo "[vc info] $msg"
}

msg_error ()
{
	msg=$1
	echo "[vc error] $msg"
	exit 1
}

msg_warn ()
{
	msg=$1
	echo "[vc warn] $msg"
}

commit_with_changelog ()
{
	msg_info "start commit process"

	# get user information
	user_name=`git config --get user.name`
	user_email=`git config --get user.email`
	tempfile=`mktemp /tmp/vc.XXXXXXXX`
	if [ $? -ne 0 ]; then
		msg_error "create tempfile fail"
	fi

	# get all local staged file (file by git add)
	staged_files=`git diff --name-only --staged`

	# redirect to tempfile and produce template
	pid=$$ 
	origin_fd_1_file=$(readlink /proc/$pid/fd/1)
	if [ $? -ne 0 ]; then
		rm $tempfile
		msg_error "readlink fail"
	fi

	if $debug; then
		echo "redirect PID=$pid stdout from $origin_fd_1_file --> $tempfile"
	fi

	exec 1>$tempfile
	if [ $? -ne 0 ]; then
		rm $tempfile
		msg_error "redirect $origin_fd_1_file --> $tempfile fail"
	fi
	echo "[Description]"
	echo ""
	echo "[Commit Files]"
	echo "$staged_files"
	echo ""
	echo "-------------------------------------------"
	exec 1>>$origin_fd_1_file
	if $debug; then
		echo "redirect stdout from $tempfile --> $origin_fd_1_file"
	fi
	if [ $? -ne 0 ]; then
		rm $tempfile
		msg_error "redirect $tempfile --> $origin_fd_1_file fail "
	fi

	# modify change log
	vim $tempfile

	# confirm commit
	printf "[confirm] commit (Y/N) ? "
	read -n 1 response
	if [ $response == "Y" -o $response == "y" ]; then
		echo -e "\ncommit ..."
		git commit -F $tempfile

		# push file to local branch (master) to remote repository (origin)
		git push origin master
	else
		echo -e "\nabort"
	fi

	# clean-up
	rm $tempfile
}

query_file_status ()
{
	msg_info "start query status"
	
	file=$*
	git status --untracked-file=no -s $file
	if [ $? -ne 0 ]; then
		msg_error "query '$file' status fail "
	fi
}

add_file ()
{
	file=$*
	msg_info "add file '$file'"
	
	git add $file

	if [ $? -ne 0 ]; then
		msg_error "add '$file' fail "
	fi
}

reset_file ()
{
	msg_info "reset '$file'"
	
	file=$*
	git reset -- $file

	if [ $? -ne 0 ]; then
		msg_error "reset '$file' fail "
	fi
}

deleted_file ()
{
	msg_info "delete '$file'"
	
	file=$*
	git rm -- $file

	if [ $? -ne 0 ]; then
		msg_error "delete '$file' fail "
	fi
}

query_file_change_log ()
{
	msg_info "start query change log"
	
	file=$*
	git log --date=iso --abbrev-commit --pretty=format:"%h [%an] %ad %s" $remote_branch -- $file
	if [ $? -ne 0 ]; then
		msg_error "query '$file' cnange log fail "
	fi
}

update_all_file ()
{
	msg_info "update all file"

	# update (merge FETCH_HEAD)
	git merge origin/master
	if [ $? -ne 0 ]; then
		msg_error "merge FETCH_HEAD fail "
	fi
}

update_single_file ()
{
	file=$1
	msg_info "update file '$file'"
}

get_missing_file ()
{
	local_branch=`git rev-parse --abbrev-ref HEAD`
	if [ $? -ne 0 ]; then
		msg_error "get local branch fail "
	fi

	msg_info "start merge file from branch $remote_branch to $local_branch"

	deleted_files=`git status --short | grep -E '^ D' | sed 's/^ D\s\+//'` # only sync "^ D" not "^D" (later is user use git rm)
	if [ $? -eq 0 ]; then
		for file in $deleted_files; do
			printf "[confirm] download mssing file '$file' (Y/N) ? "
			read -n 1 response
			if [ $response == "Y" -o $response == "y" ]; then
				echo -e "\ndownload '$file' ..."
				git checkout $remote_branch -- $file
				if [ $? -ne 0 ]; then
					msg_error "checkout file fail "
				fi
			else
				echo ""
			fi
		done
	fi
}

diff_files ()
{
	msg_info "start diff file"

	vimdiff_version=`vimdiff --version`
	if [ $? -ne 0 ]; then
		msg_error "cannot find vimdiff"
	fi

	num_args=$#
	if [ $num_args -eq 1 ]; then
		file=$1
		git difftool --no-prompt --tool=vimdiff $remote_branch -- $file
		if [ $? -ne 0 ]; then
			msg_error "diff '$file' fail "
		fi
	elif [ $num_args -eq 3 ]; then
		file=$1
		commit_id1=$2
		commit_id2=$3
		git difftool --no-prompt --tool=vimdiff $commit_id1 $commit_id2 -- $file
		if [ $? -ne 0 ]; then
	 		msg_error "diff '$file' fail "
		fi
	else
		msg_error "invalid diff arguments"
	fi
}

show_conflict_list ()
{
	msg_info "start show conflict list"

	dir=`pwd`
	git diff --name-only $remote_branch -- $dir
	if [ $? -ne 0 ]; then
		msg_error "diff '$dir' fail "
	fi
}

get_file ()
{
	msg_info "start get file"

	num_args=$#
	if [ $num_args -eq 2 ]; then
		file=$1
		commit_id=$2
		dump_name="${file}#${commit_id}"
		git show $commit_id:$file > $dump_name
		if [ $? -ne 0 ]; then
			rm -f $dump_name
			msg_error "get '$file (id=$commit_id)' fail"
		else
			msg_info "dump file '$dump_name'"
		fi
	else
		msg_error "invalid get arguments"
	fi
}

merge_file ()
{
	local_branch=`git rev-parse --abbrev-ref HEAD`
	if [ $? -ne 0 ]; then
		msg_error "get local branch fail "
	fi

	msg_info "start merge file from branch $remote_branch to $local_branch"

	file=$1
	git checkout $remote_branch -- $file
	if [ $? -ne 0 ]; then
		msg_error "checkout file fail "
	fi
}

fetch_remote_info ()
{
	# get branch head of remote repositories
	git fetch
	if [ $? -ne 0 ]; then
		msg_error "get fetch fail "
	fi

}


show_help ()
{
	echo "-----------------------------"
	echo "|            VCS            |"
	echo "-----------------------------"
	echo "[update remote infomation]"
	echo "  vc"
	echo ""
	echo "[query status]"
	echo "  vc -t|--status file ..."
	echo ""
	echo "[query log]"
	echo "  vc -l|--log file ..."
	echo ""
	echo "[add file]"
	echo "  vc -a|--add file ..."
	echo ""
	echo "[reset file]"
	echo "  vc -r|--reset file ..."
	echo ""
	echo "[commit and edit change log]"
	echo "  vc -c|--commit"
	echo ""
	echo "[sync file]"
	echo "  vc -s|--sync"
	echo ""
	echo "[diff file]"
	echo "  vc -d|--diff file"
	echo "  vc -d|--diff file commit_id1 commit_id2"
	echo ""
	echo "[show conflict]"
	echo "  vc -f|--conflict"
	echo ""
	echo "[get file]"
	echo "  vc -g|--get file commit_id (dump to file#commit_id)"
	echo ""
	echo "[merge file]"
	echo "  vc -m|--merge file (replace local file by remote branch file)"
	echo ""
	echo "[delete file]"
	echo "  vc -x|--delete file"
}

# fetch latest remote branch information
if [ $# -eq 0 ]; then
	echo "fetch remote branch information ..."
	fetch_remote_info
	exit 0
fi

# $@ is array of arguments, $* is single string contain all arguments
args="$@"

# change -s file1 file2  ==>  -s "file1 file2"
quote_args=`echo $args | sed 's/\(--\?[^- ]\+\) \([^-]\+\)$/\1 "\2"/g'`

# change -s file1 file2 -h   ==>  -s "file1 file2" -h
quote_args=`echo $quote_args | sed 's/\(--\?[^- ]\+\) \([^-]\+\) -/\1 "\2" -/g'`

# assign quote_args to $@, and set will assign each arg to $1, $2 ...
eval set -- "$quote_args" 

if $debug; then
	msg_info "arguments: $args"
	msg_info "quote arguments: $quote_args"
fi

# use getopt to parse command line arguments, use "$@" in for loop will handle quote string
options=$(getopt -o vht:ca:r:l:sd:g:fm:u:x: --long version,help,status:,commit,add:,reset:,log:,sync,diff:,conflict,get:,merge:,update:,delete: -- "$@")

return_val=$?
if [ $return_val -ne 0 ]; then
	msg_error "parse command line arguments fail (return $return_val)"
fi

if $debug; then
	msg_info "options: $options" # -- mean end of options, it will not process by eval set
fi

# set -- assign $options to $1, $2 ...
eval set -- "$options" 

eof_argument=false
while [ !$eof_argument ]; do
	option=$1
	case "$option" in 
	-h)
		show_help
		;;
	-v|--version)
		echo "vc 1.0"
		echo "$(git --version)"
		;;
	-t|--status)
		shift 
		args=$1
		query_file_status $args
		;;
	-c|--commit)
		commit_with_changelog 
		;;
	-a|--add)
		shift 
		args=$1
		add_file $args
		;;
	-r|--reset)
		shift 
		args=$1
		reset_file $args
		;;
	-l|--log)
		shift 
		args=$1
		query_file_change_log $args
		;;
	-s|--sync)
		update_all_file 
		get_missing_file
		;;
	-u|--update)
		shift
		args=$1
		update_single_file $args
		;;
	-d|--diff)
		shift
		args=$1
		diff_files $args
		;;
	-f|--conflict)
		show_conflict_list 
		;;
	-g|--get)
		shift
		args=$1
		get_file $args
		;;
	-m|--merge)
		shift
		args=$1
		merge_file $args
		;;
	-x|--delete)
		shift
		args=$1
		deleted_file $args
		;;
	--) 
		# -- (end of options)
		shift 
		eof_argument=true
		break
		;;
	esac

	shift # move $1 to next argument
done
