#!/bin/bash

msg_info ()
{
	msg=$1
	echo "[vc info] $msg"
}

msg_error ()
{
	msg=$1
	echo "[vc error] $msg"
	exit 1
}

msg_warn ()
{
	msg=$1
	echo "[vc warn] $msg"
}

commit_with_changelog ()
{
	msg_info "start commit process"

	# fetch user information
	user_name=`git config --get user.name`
	user_email=`git config --get user.email`
	tempfile=`mktemp /tmp/vc.XXXXXXXX`
	if [ $? -ne 0 ]; then
		msg_error "create tempfile fail"
	fi

	# redirect to tempfile and produce template
	pid=$$ 
	origin_fd_1_file=$(readlink /proc/$pid/fd/1)
	if [ $? -ne 0 ]; then
		msg_error "readlink fail"
	fi

	echo "redirect PID=$pid stdout from $origin_fd_1_file --> $tempfile"
	exec 1>$tempfile
	if [ $? -ne 0 ]; then
		msg_error "redirect $origin_fd_1_file --> $tempfile fail"
	fi
	echo "-------------------------------------------"
	echo "user  = ${user_name}"
	echo "email = ${user_email}"
	echo "[Description]"
	echo ""
	echo "[Commit Files]"
	echo ""
	exec 1>>$origin_fd_1_file
	echo "redirect stdout from $tempfile --> $origin_fd_1_file"
	if [ $? -ne 0 ]; then
		msg_error "redirect $tempfile --> $origin_fd_1_file fail "
	fi

	# modify change log
	vim $tempfile

	# confirm commit
	printf "[confirm] commit (Y/N) ? "
	read -n 1 response
	if [ $response == "Y" -o $response == "y" ]; then
		echo -e "\ncommit ..."
		git commit -F $tempfile
	else
		echo -e "\nabort"
	fi

	# clean-up
	rm $tempfile
}

query_file_status ()
{
	msg_info "start query status"
	
	file=$1
	git status $1
	if [ $? -ne 0 ]; then
		msg_error "query '$file' status fail "
	fi
}

checkout_file ()
{
	msg_info "check out '$file'"
	
	file=$1
	git add $1

	if [ $? -ne 0 ]; then
		msg_error "check out '$file' fail "
	fi
}

revert_file ()
{
	msg_info "revert '$file'"
	
	file=$1
	git reset $1

	if [ $? -ne 0 ]; then
		msg_error "revert '$file' fail "
	fi
}

query_file_change_log ()
{
	msg_info "start query change log"
	
	file=$1
	git log $1
	if [ $? -ne 0 ]; then
		msg_error "query '$file' cnange log fail "
	fi
}

msg_info "arguments: $@"

# use getopt to parse command line arguments
options=$(getopt -o vhs:co:r:l: --long version,status:,commit,checkout:,revert:,log: -- "$@")

return_val=$?
if [ $return_val -ne 0 ]; then
	msg_error "parse command line arguments fail (return $return_val)"
fi

msg_info "options: $options" # -- mean end of options, it will not process by eval set

# set -- assign $options to $1, $2 ...
eval set -- "$options" 

eof_argument=false
while [ !$eof_argument ]; do
	case "$1" in 
	-h)
		echo "help"
		;;
	-v|--version)
		echo "$(git --version)"
		;;
	-s|--status)
		shift 
		file=$1
		query_file_status $file
		;;
	-c|--commit)
		commit_with_changelog 
		;;
	-o|--checkout)
		shift 
		file=$1
		checkout_file $file
		;;
	-r|--revert)
		shift 
		file=$1
		revert_file $file
		;;
	-l|--log)
		shift 
		file=$1
		query_file_change_log $file
		;;
	--) 
		# -- (end of options)
		shift 
		eof_argument=true
		break
		;;
	esac

	shift # move $1 to next argument
done
